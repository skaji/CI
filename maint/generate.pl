#!/usr/bin/env perl
use strict;
use warnings;

use FindBin;
use HTTP::Tiny;
use JSON::XS ();
use Path::Tiny;

chdir $FindBin::Bin;

my $target = "../lib/CI.pm";
my $VERSION = '0.001';
if (-f $target) {
    if (path($target)->slurp =~ /^our \$VERSION = ["']([\d.]+)/sm) {
        $VERSION = $1;
    }
}

my $res = HTTP::Tiny->new->mirror(
    "https://raw.githubusercontent.com/watson/ci-info/master/vendors.json",
    "vendors.json",
);
die if !$res->{success};

sub is_condition {
    my @out;
    for my $value (@_) {
        my $ref = ref $value;
        if ($ref eq 'ARRAY') {
            push @out, is_condition(@$value);
        } elsif ($ref eq 'HASH') {
            for my $key (sort keys %$value) {
                push @out, "exists \$ENV{$key} && \$ENV{$key} eq '$value->{$key}'";
            }
        } else {
            push @out, "exists \$ENV{$value}";
        }
    }
    @out;
}

sub is_pr_condition {
    my $value = shift;
    my $ref = ref $value;
    if ($ref eq 'HASH') {
        if (exists $value->{env}) {
            "exists \$ENV{$value->{env}} && \$ENV{$value->{env}} ne '$value->{ne}'";
        } elsif (exists $value->{any}) {
            join ' || ', map { "exists \$ENV{$_}" } @{$value->{any}};
        } else {
            is_condition $value;
        }
    } elsif ($ref eq '' && !defined $value) {
        "0";
    } else {
        "exists \$ENV{$value}";
    }
}

my $vendors = JSON::XS->new->utf8->decode( path("vendors.json")->slurp );

open my $FH, ">", "../lib/CI.pm.tmp" or die;
select $FH;

print <<"___";
package CI;
# DO NOT EDIT THIS; This file is automatically generated by maint/generate.pl
use strict;
use warnings;

our \$VERSION = '$VERSION';

use Exporter 'import';

our \@EXPORT_OK = qw(
    is_ci
    name
    is_pr
___
my $constant = join "\n", map { $_->{constant} } @$vendors;
$constant =~ s/^/    /msg;
print $constant, "\n);\n\n";

print <<"___";
our %EXPORT_TAGS = (
    constant => [qw(
___
my $constant2 = join "\n", map { $_->{constant} } @$vendors;
$constant2 =~ s/^/        /msg;
print $constant2, "\n    )],\n);\n\n";

print "use constant _CI => exists \$ENV{CI} || exists \$ENV{CONTINUOUS_INTEGRATION} || exists \$ENV{RUN_ID};\n";
for my $vendor (@$vendors) {
    my $constant = $vendor->{constant};
    my @condition = is_condition $vendor->{env};

    print "use constant $constant => " . ( join ' && ', @condition ) . ";\n"
}

print "\n";
print "sub is_ci () {\n";
my $is_ci = join "\n|| ", ('_CI', map { $_->{constant} } @$vendors);
$is_ci =~ s/^/    /msg;
print $is_ci, "\n}\n";

print "\n";
print "sub name () {\n";
my $name = join "\n: ", map { "$_ ? '$_'" } map { $_->{constant} } @$vendors;
$name =~ s/^/    /msg;
print $name, "\n    : undef\n}\n";

my @is_pr;
for my $vendor (@$vendors) {
    my $constant = $vendor->{constant};
    my $is_pr_condition = is_pr_condition $vendor->{pr};
    push @is_pr, "$constant && $is_pr_condition";
}

print "\n";
print "sub is_pr () {\n";
my $is_pr = join "\n|| ", map { "( $_ )" } @is_pr;
$is_pr =~ s/^/    /msg;
print $is_pr, "\n}\n";

print "\n1;\n__END__\n\n";
print path("main.pod")->slurp;

select \*STDOUT;
close $FH;
rename "../lib/CI.pm.tmp", "../lib/CI.pm" or die;
