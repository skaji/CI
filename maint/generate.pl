#!/usr/bin/env perl
use strict;
use warnings;

use FindBin;
use HTTP::Tiny;
use JSON::XS ();
use Path::Tiny;

chdir $FindBin::Bin;

my $target = "../lib/Test/CI.pm";
my $VERSION = '0.001';
if (-f $target) {
    if (path($target)->slurp =~ /^our \$VERSION = ["']([\d.]+)/sm) {
        $VERSION = $1;
    }
}

my $res = HTTP::Tiny->new->mirror(
    "https://raw.githubusercontent.com/watson/ci-info/master/vendors.json",
    "vendors.json",
);
die if !$res->{success};

sub is_condition {
    my @out;
    for my $value (@_) {
        my $ref = ref $value;
        if ($ref eq 'ARRAY') {
            push @out, is_condition(@$value);
        } elsif ($ref eq 'HASH') {
            for my $key (sort keys %$value) {
                push @out, "exists \$ENV{$key} && \$ENV{$key} eq '$value->{$key}'";
            }
        } else {
            push @out, "exists \$ENV{$value}";
        }
    }
    @out;
}

sub is_pr_condition {
    my $value = shift;
    my $ref = ref $value;
    if ($ref eq 'HASH') {
        if (exists $value->{env}) {
            "exists \$ENV{$value->{env}} && \$ENV{$value->{env}} ne '$value->{ne}'";
        } elsif (exists $value->{any}) {
            join ' || ', map { "exists \$ENV{$_}" } @{$value->{any}};
        } else {
            join ' && ', is_condition $value;
        }
    } elsif ($ref eq '' && !defined $value) {
        undef;
    } else {
        "exists \$ENV{$value}";
    }
}

my $vendors = JSON::XS->new->utf8->decode( path("vendors.json")->slurp );
if (-f "custom-vendors.json") {
    my $custom = JSON::XS->new->utf8->decode( path("custom-vendors.json")->slurp );
    push @$vendors, @$custom;
    @$vendors = sort { $a->{constant} cmp $b->{constant} } @$vendors;
}

open my $FH, ">", "../lib/Test/CI.pm.tmp" or die;
select $FH;

print <<"___";
package Test::CI;
# DO NOT EDIT THIS; This file is automatically generated by maint/generate.pl
use strict;
use warnings;

our \$VERSION = '$VERSION';

use Exporter 'import';

our \@EXPORT_OK = qw(
    is_ci
    name
    is_pr
___
my $constant = join "\n", map { $_->{constant} } @$vendors;
$constant =~ s/^/    /msg;
print $constant, "\n);\n\n";

print <<"___";
our %EXPORT_TAGS = (
    constant => [qw(
___
my $constant2 = join "\n", map { $_->{constant} } @$vendors;
$constant2 =~ s/^/        /msg;
print $constant2, "\n    )],\n);\n\n";

print "use constant _CI => exists \$ENV{CI} || exists \$ENV{CONTINUOUS_INTEGRATION} || exists \$ENV{RUN_ID} ? 1 : 0;\n";
for my $vendor (@$vendors) {
    my $constant = $vendor->{constant};
    my @condition = is_condition $vendor->{env};

    print "use constant $constant => " . ( join ' && ', @condition ) . " ? 1 : 0;\n"
}

print "\n";
print "sub is_ci () {\n";
my $is_ci = join "\n|| ", ('_CI', map { $_->{constant} } @$vendors);
$is_ci =~ s/^/    /msg;
print $is_ci, "\n}\n";

print "\n";
print "sub name () {\n";
my $name = join "\n: ", map { "$_->{constant} ? '$_->{name}'" } @$vendors;
$name =~ s/^/    /msg;
print $name, "\n    : undef\n}\n";


print "\n";
print "sub is_pr () {\n";
for my $vendor (@$vendors) {
    my $constant = $vendor->{constant};
    my $is_pr_condition = is_pr_condition $vendor->{pr};
    next if !$is_pr_condition;
    print "    return $is_pr_condition ? 1 : 0 if $constant;\n";
}
print "    return undef;\n";
print "}\n";

print "\n1;\n__END__\n\n";
print path("main.pod")->slurp;

select \*STDOUT;
close $FH;
rename "../lib/Test/CI.pm.tmp", "../lib/Test/CI.pm" or die;
